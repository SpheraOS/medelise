'use client';

import { useEffect, useRef, useCallback } from 'react';
import * as THREE from 'three';

/* ─── helpers ─── */
const CODE_CHARS =
    'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789(){}[]<>;:,._-+=!@#$%^&*|\\/"\x27`~?';

function randInt(min: number, max: number) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
function pick<T>(arr: T[]): T {
    return arr[randInt(0, arr.length - 1)];
}
function randomFloat(min: number, max: number) {
    return Math.random() * (max - min) + min;
}

/* ─── code generation for ASCII overlay ─── */
function generateCode(width: number, height: number): string {
    const header = [
        '// compiled preview • scanner demo',
        '/* generated for visual effect – not executed */',
        'const SCAN_WIDTH = 8;',
        'const FADE_ZONE = 35;',
        'const MAX_PARTICLES = 2500;',
        'const TRANSITION = 0.05;',
    ];
    const helpers = [
        'function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }',
        'function lerp(a, b, t) { return a + (b - a) * t; }',
        'const now = () => performance.now();',
        'function rng(min, max) { return Math.random() * (max - min) + min; }',
    ];
    const particleBlock = (idx: number) => [
        `class Particle${idx} {`,
        '  constructor(x, y, vx, vy, r, a) {',
        '    this.x = x; this.y = y;',
        '    this.vx = vx; this.vy = vy;',
        '    this.r = r; this.a = a;',
        '  }',
        '  step(dt) { this.x += this.vx * dt; this.y += this.vy * dt; }',
        '}',
    ];
    const scannerBlock = [
        'const scanner = {',
        '  x: Math.floor(window.innerWidth / 2),',
        '  width: SCAN_WIDTH,',
        '  glow: 3.5,',
        '};',
        '',
        'function drawParticle(ctx, p) {',
        '  ctx.globalAlpha = clamp(p.a, 0, 1);',
        '  ctx.drawImage(gradient, p.x - p.r, p.y - p.r, p.r * 2, p.r * 2);',
        '}',
    ];
    const loopBlock = [
        'function tick(t) {',
        '  const dt = 0.016;',
        '}',
    ];
    const misc = [
        "const state = { intensity: 1.2, particles: MAX_PARTICLES };",
        "const bounds = { w: window.innerWidth, h: 300 };",
        "const gradient = document.createElement('canvas');",
        "const ctx = gradient.getContext('2d');",
        "ctx.globalCompositeOperation = 'lighter';",
    ];

    const library: string[] = [];
    header.forEach(l => library.push(l));
    helpers.forEach(l => library.push(l));
    for (let b = 0; b < 3; b++) particleBlock(b).forEach(l => library.push(l));
    scannerBlock.forEach(l => library.push(l));
    loopBlock.forEach(l => library.push(l));
    misc.forEach(l => library.push(l));
    for (let i = 0; i < 40; i++) {
        library.push(`const v${i} = (${randInt(1, 9)} + ${randInt(10, 99)}) * 0.${randInt(1, 9)};`);
    }

    let flow = library.join(' ').replace(/\s+/g, ' ').trim();
    const totalChars = width * height;
    while (flow.length < totalChars + width) {
        flow += ' ' + pick(library).replace(/\s+/g, ' ').trim();
    }

    let out = '';
    let offset = 0;
    for (let row = 0; row < height; row++) {
        let line = flow.slice(offset, offset + width);
        if (line.length < width) line += ' '.repeat(width - line.length);
        out += line + (row < height - 1 ? '\n' : '');
        offset += width;
    }
    return out;
}

function calcCodeDims(cardW: number, cardH: number) {
    const fontSize = 11;
    const lineHeight = 13;
    const charWidth = 6;
    return {
        width: Math.floor(cardW / charWidth),
        height: Math.floor(cardH / lineHeight),
        fontSize,
        lineHeight,
    };
}

/* ─── card images ─── */
const CARD_IMAGES = [
    '/images/security/Touch ID.png',
];

/* ═══════════════════════════════════════════════════════
   CardScanner  —  self-contained React component
   ═══════════════════════════════════════════════════════ */
export default function CardScanner() {
    const containerRef = useRef<HTMLDivElement>(null);
    const particleCanvasRef = useRef<HTMLCanvasElement>(null);
    const scannerCanvasRef = useRef<HTMLCanvasElement>(null);
    const cardLineRef = useRef<HTMLDivElement>(null);
    const cleanupRef = useRef<(() => void) | null>(null);

    /* ── build card DOM ── */
    const buildCards = useCallback(() => {
        const line = cardLineRef.current;
        if (!line) return;
        line.innerHTML = '';

        const CARD_W = 240;
        const CARD_H = 150;
        const count = 30;

        for (let i = 0; i < count; i++) {
            const wrapper = document.createElement('div');
            wrapper.className = 'cs-card-wrapper';

            /* normal card (image) */
            const normal = document.createElement('div');
            normal.className = 'cs-card cs-card-normal';
            const img = document.createElement('img');
            img.className = 'cs-card-image';
            img.src = CARD_IMAGES[i % CARD_IMAGES.length];
            img.alt = 'Card';
            img.onerror = () => {
                const c = document.createElement('canvas');
                c.width = CARD_W; c.height = CARD_H;
                const cx = c.getContext('2d')!;
                const g = cx.createLinearGradient(0, 0, CARD_W, CARD_H);
                g.addColorStop(0, '#667eea'); g.addColorStop(1, '#764ba2');
                cx.fillStyle = g; cx.fillRect(0, 0, CARD_W, CARD_H);
                img.src = c.toDataURL();
            };
            normal.appendChild(img);

            /* ASCII card */
            const ascii = document.createElement('div');
            ascii.className = 'cs-card cs-card-ascii';
            const asciiContent = document.createElement('div');
            asciiContent.className = 'cs-ascii-content';
            const dims = calcCodeDims(CARD_W, CARD_H);
            asciiContent.style.fontSize = dims.fontSize + 'px';
            asciiContent.style.lineHeight = dims.lineHeight + 'px';
            asciiContent.textContent = generateCode(dims.width, dims.height);
            ascii.appendChild(asciiContent);

            wrapper.appendChild(normal);
            wrapper.appendChild(ascii);
            line.appendChild(wrapper);
        }
    }, []);

    /* ── main effect ── */
    useEffect(() => {
        const container = containerRef.current;
        const particleCanvas = particleCanvasRef.current;
        const scannerCanvas = scannerCanvasRef.current;
        const cardLine = cardLineRef.current;
        if (!container || !particleCanvas || !scannerCanvas || !cardLine) return;

        buildCards();

        /* sizes relative to the container */
        let cW = container.offsetWidth;
        let cH = container.offsetHeight;

        /* ── Card Stream Controller ── */
        let position = cW;
        let velocity = 70;
        let direction = -1;
        let isAnimating = true;
        let isDragging = false;
        let lastMouseX = 0;
        let mouseVelocity = 0;
        const friction = 0.95;
        const minVelocity = 45;
        let lastTime = performance.now();

        const cardWidth = 240;
        const cardGap = 60;
        const cardCount = cardLine.children.length;
        let cardLineWidth = (cardWidth + cardGap) * cardCount;

        /* clipping / scanning */
        let scanningActive = false;

        function updateCardClipping() {
            const scannerX = cW / 2;
            const scannerWidth = 8;
            const sLeft = scannerX - scannerWidth / 2;
            const sRight = scannerX + scannerWidth / 2;
            let anyActive = false;

            const containerRect = container!.getBoundingClientRect();

            cardLine!.querySelectorAll('.cs-card-wrapper').forEach((w) => {
                const wrapper = w as HTMLElement;
                const rect = wrapper.getBoundingClientRect();
                const cardLeft = rect.left - containerRect.left;
                const cardRight = rect.right - containerRect.left;
                const cardW = rect.width;

                const normalCard = wrapper.querySelector('.cs-card-normal') as HTMLElement;
                const asciiCard = wrapper.querySelector('.cs-card-ascii') as HTMLElement;
                if (!normalCard || !asciiCard) return;

                if (cardLeft < sRight && cardRight > sLeft) {
                    anyActive = true;
                    const intersectLeft = Math.max(sLeft - cardLeft, 0);
                    const intersectRight = Math.min(sRight - cardLeft, cardW);
                    const normalClipRight = (intersectLeft / cardW) * 100;
                    const asciiClipLeft = (intersectRight / cardW) * 100;
                    normalCard.style.setProperty('--clip-right', `${normalClipRight}%`);
                    asciiCard.style.setProperty('--clip-left', `${asciiClipLeft}%`);

                    if (!wrapper.hasAttribute('data-scanned') && intersectLeft > 0) {
                        wrapper.setAttribute('data-scanned', 'true');
                        const fx = document.createElement('div');
                        fx.className = 'cs-scan-effect';
                        wrapper.appendChild(fx);
                        setTimeout(() => fx.remove(), 600);
                    }
                } else {
                    if (cardRight < sLeft) {
                        normalCard.style.setProperty('--clip-right', '100%');
                        asciiCard.style.setProperty('--clip-left', '100%');
                    } else {
                        normalCard.style.setProperty('--clip-right', '0%');
                        asciiCard.style.setProperty('--clip-left', '0%');
                    }
                    wrapper.removeAttribute('data-scanned');
                }
            });
            scanningActive = anyActive;
        }

        function updateCardPosition() {
            if (position < -cardLineWidth) position = cW;
            else if (position > cW) position = -cardLineWidth;
            cardLine!.style.transform = `translateX(${position}px)`;
            updateCardClipping();
        }

        /* drag */
        function startDrag(e: MouseEvent | Touch) {
            isDragging = true;
            isAnimating = false;
            lastMouseX = e.clientX;
            mouseVelocity = 0;
            const tf = window.getComputedStyle(cardLine!).transform;
            if (tf !== 'none') { position = new DOMMatrix(tf).m41; }
            cardLine!.style.cursor = 'grabbing';
        }
        function onDrag(e: MouseEvent | Touch) {
            if (!isDragging) return;
            const dx = e.clientX - lastMouseX;
            position += dx;
            mouseVelocity = dx * 60;
            lastMouseX = e.clientX;
            cardLine!.style.transform = `translateX(${position}px)`;
            updateCardClipping();
        }
        function endDrag() {
            if (!isDragging) return;
            isDragging = false;
            cardLine!.style.cursor = 'grab';
            if (Math.abs(mouseVelocity) > minVelocity) {
                velocity = Math.abs(mouseVelocity);
                direction = mouseVelocity > 0 ? 1 : -1;
            } else { velocity = 70; }
            isAnimating = true;
        }

        const onMouseDown = (e: MouseEvent) => { e.preventDefault(); startDrag(e); };
        const onMouseMove = (e: MouseEvent) => { if (isDragging) { e.preventDefault(); onDrag(e); } };
        const onMouseUp = () => endDrag();
        const onTouchStart = (e: TouchEvent) => { e.preventDefault(); startDrag(e.touches[0]); };
        const onTouchMove = (e: TouchEvent) => { if (isDragging) onDrag(e.touches[0]); };
        const onTouchEnd = () => endDrag();
        const onWheel = (e: WheelEvent) => { e.preventDefault(); position += e.deltaY > 0 ? 20 : -20; updateCardPosition(); };

        cardLine.addEventListener('mousedown', onMouseDown);
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
        cardLine.addEventListener('touchstart', onTouchStart, { passive: false });
        document.addEventListener('touchmove', onTouchMove, { passive: false });
        document.addEventListener('touchend', onTouchEnd);
        cardLine.addEventListener('wheel', onWheel, { passive: false });

        /* card stream animation loop */
        let cardRafId: number;
        function animateCards() {
            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;
            if (isAnimating && !isDragging) {
                if (velocity > minVelocity) velocity *= friction;
                else velocity = Math.max(minVelocity, velocity);
                position += velocity * direction * dt;
                updateCardPosition();
            }
            cardRafId = requestAnimationFrame(animateCards);
        }
        animateCards();

        /* periodic ascii refresh */
        const asciiTimer = setInterval(() => {
            cardLine.querySelectorAll('.cs-ascii-content').forEach(el => {
                if (Math.random() < 0.15) {
                    const dims = calcCodeDims(240, 150);
                    el.textContent = generateCode(dims.width, dims.height);
                }
            });
        }, 200);

        /* ── Particle System (Three.js) ── */
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-cW / 2, cW / 2, 125, -125, 1, 1000);
        camera.position.z = 100;
        const renderer = new THREE.WebGLRenderer({ canvas: particleCanvas, alpha: true, antialias: true });
        renderer.setSize(cW, 250);
        renderer.setClearColor(0x000000, 0);

        const pCount = 400;
        const positions = new Float32Array(pCount * 3);
        const colors = new Float32Array(pCount * 3);
        const alphas = new Float32Array(pCount);
        const velocitiesArr = new Float32Array(pCount);

        for (let i = 0; i < pCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * cW * 2;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 250;
            positions[i * 3 + 2] = 0;
            colors[i * 3] = colors[i * 3 + 1] = colors[i * 3 + 2] = 1;
            alphas[i] = (Math.random() * 8 + 2) / 10;
            velocitiesArr[i] = Math.random() * 60 + 30;
        }

        /* particle dot texture */
        const dotCanvas = document.createElement('canvas');
        dotCanvas.width = dotCanvas.height = 100;
        const dCtx = dotCanvas.getContext('2d')!;
        const half = 50;
        const dGrad = dCtx.createRadialGradient(half, half, 0, half, half, half);
        dGrad.addColorStop(0.025, '#fff');
        dGrad.addColorStop(0.1, 'hsl(217,61%,33%)');
        dGrad.addColorStop(0.25, 'hsl(217,64%,6%)');
        dGrad.addColorStop(1, 'transparent');
        dCtx.fillStyle = dGrad;
        dCtx.beginPath(); dCtx.arc(half, half, half, 0, Math.PI * 2); dCtx.fill();
        const dotTexture = new THREE.CanvasTexture(dotCanvas);

        const geom = new THREE.BufferGeometry();
        geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geom.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));

        const mat = new THREE.ShaderMaterial({
            uniforms: { pointTexture: { value: dotTexture }, size: { value: 15.0 } },
            vertexShader: `
        attribute float alpha;
        varying float vAlpha;
        varying vec3 vColor;
        uniform float size;
        void main(){
          vAlpha=alpha; vColor=color;
          vec4 mv=modelViewMatrix*vec4(position,1.0);
          gl_PointSize=size;
          gl_Position=projectionMatrix*mv;
        }`,
            fragmentShader: `
        uniform sampler2D pointTexture;
        varying float vAlpha;
        varying vec3 vColor;
        void main(){
          gl_FragColor=vec4(vColor,vAlpha)*texture2D(pointTexture,gl_PointCoord);
        }`,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            vertexColors: true,
        });

        const points = new THREE.Points(geom, mat);
        scene.add(points);

        let threeRafId: number;
        function animateThree() {
            const pos = geom.attributes.position.array as Float32Array;
            const alp = geom.attributes.alpha.array as Float32Array;
            const t = Date.now() * 0.001;
            for (let i = 0; i < pCount; i++) {
                pos[i * 3] += velocitiesArr[i] * 0.016;
                if (pos[i * 3] > cW / 2 + 100) {
                    pos[i * 3] = -cW / 2 - 100;
                    pos[i * 3 + 1] = (Math.random() - 0.5) * 250;
                }
                pos[i * 3 + 1] += Math.sin(t + i * 0.1) * 0.5;
                const tw = Math.floor(Math.random() * 10);
                if (tw === 1 && alp[i] > 0) alp[i] -= 0.05;
                else if (tw === 2 && alp[i] < 1) alp[i] += 0.05;
                alp[i] = Math.max(0, Math.min(1, alp[i]));
            }
            geom.attributes.position.needsUpdate = true;
            geom.attributes.alpha.needsUpdate = true;
            renderer.render(scene, camera);
            threeRafId = requestAnimationFrame(animateThree);
        }
        animateThree();

        /* ── Particle Scanner (2D Canvas) ── */
        const sCtx = scannerCanvas.getContext('2d')!;
        let sW = cW;
        let sH = 300;
        scannerCanvas.width = sW;
        scannerCanvas.height = sH;

        const lightBarX = sW / 2;
        const lightBarWidth = 3;
        let fadeZone = 60;
        let intensity = 0.8;
        let maxParticles = 800;
        const baseIntensity = 0.8;
        const baseMax = 800;
        const baseFadeZone = 60;
        const scanTargetIntensity = 1.8;
        const scanTargetParticles = 2500;
        const scanTargetFadeZone = 35;
        const transitionSpeed = 0.05;
        let currentGlowIntensity = 1;

        /* gradient dot for scanner particles */
        const gradDot = document.createElement('canvas');
        gradDot.width = gradDot.height = 16;
        const gCtx = gradDot.getContext('2d')!;
        const gHalf = 8;
        const gGrd = gCtx.createRadialGradient(gHalf, gHalf, 0, gHalf, gHalf, gHalf);
        gGrd.addColorStop(0, 'rgba(255,255,255,1)');
        gGrd.addColorStop(0.3, 'rgba(196,181,253,0.8)');
        gGrd.addColorStop(0.7, 'rgba(139,92,246,0.4)');
        gGrd.addColorStop(1, 'transparent');
        gCtx.fillStyle = gGrd;
        gCtx.beginPath(); gCtx.arc(gHalf, gHalf, gHalf, 0, Math.PI * 2); gCtx.fill();

        interface SParticle {
            x: number; y: number; vx: number; vy: number;
            radius: number; alpha: number; originalAlpha: number;
            life: number; decay: number; time: number;
            twinkleSpeed: number; twinkleAmount: number;
        }
        const sParticles: (SParticle | null)[] = [];
        let sCount = 0;

        function createSParticle(): SParticle {
            const iRatio = intensity / baseIntensity;
            const sm = 1 + (iRatio - 1) * 1.2;
            const szm = 1 + (iRatio - 1) * 0.7;
            return {
                x: lightBarX + randomFloat(-lightBarWidth / 2, lightBarWidth / 2),
                y: randomFloat(0, sH),
                vx: randomFloat(0.2, 1.0) * sm,
                vy: randomFloat(-0.15, 0.15) * sm,
                radius: randomFloat(0.4, 1) * szm,
                alpha: randomFloat(0.6, 1),
                originalAlpha: 0,
                life: 1.0,
                decay: randomFloat(0.005, 0.025) * (2 - iRatio * 0.5),
                time: 0,
                twinkleSpeed: randomFloat(0.02, 0.08) * sm,
                twinkleAmount: randomFloat(0.1, 0.25),
            };
        }

        for (let i = 0; i < maxParticles; i++) {
            const p = createSParticle();
            p.originalAlpha = p.alpha;
            sCount++;
            sParticles[sCount] = p;
        }

        function drawLightBar() {
            const vGrad = sCtx.createLinearGradient(0, 0, 0, sH);
            vGrad.addColorStop(0, 'rgba(255,255,255,0)');
            vGrad.addColorStop(fadeZone / sH, 'rgba(255,255,255,1)');
            vGrad.addColorStop(1 - fadeZone / sH, 'rgba(255,255,255,1)');
            vGrad.addColorStop(1, 'rgba(255,255,255,0)');

            sCtx.globalCompositeOperation = 'lighter';

            const targetGlow = scanningActive ? 3.5 : 1;
            currentGlowIntensity += (targetGlow - currentGlowIntensity) * transitionSpeed;
            const gi = currentGlowIntensity;
            const lw = lightBarWidth;

            /* core */
            const coreG = sCtx.createLinearGradient(lightBarX - lw / 2, 0, lightBarX + lw / 2, 0);
            coreG.addColorStop(0, 'rgba(255,255,255,0)');
            coreG.addColorStop(0.3, `rgba(255,255,255,${0.9 * gi})`);
            coreG.addColorStop(0.5, `rgba(255,255,255,${1 * gi})`);
            coreG.addColorStop(0.7, `rgba(255,255,255,${0.9 * gi})`);
            coreG.addColorStop(1, 'rgba(255,255,255,0)');
            sCtx.globalAlpha = 1;
            sCtx.fillStyle = coreG;
            sCtx.beginPath();
            sCtx.roundRect(lightBarX - lw / 2, 0, lw, sH, 15);
            sCtx.fill();

            /* glow 1 */
            const g1 = sCtx.createLinearGradient(lightBarX - lw * 2, 0, lightBarX + lw * 2, 0);
            g1.addColorStop(0, 'rgba(139,92,246,0)');
            g1.addColorStop(0.5, `rgba(196,181,253,${0.8 * gi})`);
            g1.addColorStop(1, 'rgba(139,92,246,0)');
            sCtx.globalAlpha = scanningActive ? 1.0 : 0.8;
            sCtx.fillStyle = g1;
            sCtx.beginPath();
            sCtx.roundRect(lightBarX - lw * 2, 0, lw * 4, sH, 25);
            sCtx.fill();

            /* glow 2 */
            const g2 = sCtx.createLinearGradient(lightBarX - lw * 4, 0, lightBarX + lw * 4, 0);
            g2.addColorStop(0, 'rgba(139,92,246,0)');
            g2.addColorStop(0.5, `rgba(139,92,246,${0.4 * gi})`);
            g2.addColorStop(1, 'rgba(139,92,246,0)');
            sCtx.globalAlpha = scanningActive ? 0.8 : 0.6;
            sCtx.fillStyle = g2;
            sCtx.beginPath();
            sCtx.roundRect(lightBarX - lw * 4, 0, lw * 8, sH, 35);
            sCtx.fill();

            if (scanningActive) {
                const g3 = sCtx.createLinearGradient(lightBarX - lw * 8, 0, lightBarX + lw * 8, 0);
                g3.addColorStop(0, 'rgba(139,92,246,0)');
                g3.addColorStop(0.5, 'rgba(139,92,246,0.2)');
                g3.addColorStop(1, 'rgba(139,92,246,0)');
                sCtx.globalAlpha = scanningActive ? 0.6 : 0.4;
                sCtx.fillStyle = g3;
                sCtx.beginPath();
                sCtx.roundRect(lightBarX - lw * 8, 0, lw * 16, sH, 45);
                sCtx.fill();
            }

            sCtx.globalCompositeOperation = 'destination-in';
            sCtx.globalAlpha = 1;
            sCtx.fillStyle = vGrad;
            sCtx.fillRect(0, 0, sW, sH);
        }

        let scanRafId: number;
        function animateScanner() {
            const tI = scanningActive ? scanTargetIntensity : baseIntensity;
            const tM = scanningActive ? scanTargetParticles : baseMax;
            const tF = scanningActive ? scanTargetFadeZone : baseFadeZone;
            intensity += (tI - intensity) * transitionSpeed;
            maxParticles = Math.floor(maxParticles + (tM - maxParticles) * transitionSpeed);
            fadeZone += (tF - fadeZone) * transitionSpeed;

            sCtx.globalCompositeOperation = 'source-over';
            sCtx.clearRect(0, 0, sW, sH);
            drawLightBar();
            sCtx.globalCompositeOperation = 'lighter';

            for (let i = 1; i <= sCount; i++) {
                const p = sParticles[i];
                if (!p) continue;
                p.x += p.vx; p.y += p.vy; p.time++;
                p.alpha = p.originalAlpha * p.life + Math.sin(p.time * p.twinkleSpeed) * p.twinkleAmount;
                p.life -= p.decay;
                if (p.x > sW + 10 || p.life <= 0) {
                    p.x = lightBarX + randomFloat(-lightBarWidth / 2, lightBarWidth / 2);
                    p.y = randomFloat(0, sH);
                    p.vx = randomFloat(0.2, 1.0);
                    p.vy = randomFloat(-0.15, 0.15);
                    p.alpha = randomFloat(0.6, 1);
                    p.originalAlpha = p.alpha;
                    p.life = 1.0;
                    p.time = 0;
                }
                if (p.life <= 0) continue;
                let fa = 1;
                if (p.y < fadeZone) fa = p.y / fadeZone;
                else if (p.y > sH - fadeZone) fa = (sH - p.y) / fadeZone;
                fa = Math.max(0, Math.min(1, fa));
                sCtx.globalAlpha = p.alpha * fa;
                sCtx.drawImage(gradDot, p.x - p.radius, p.y - p.radius, p.radius * 2, p.radius * 2);
            }

            /* spawn more particles based on intensity */
            const iRatio = intensity / baseIntensity;
            if (Math.random() < intensity && sCount < maxParticles) {
                const np = createSParticle(); np.originalAlpha = np.alpha; sCount++; sParticles[sCount] = np;
            }
            if (iRatio > 1.1 && Math.random() < (iRatio - 1.0) * 1.2) {
                const np = createSParticle(); np.originalAlpha = np.alpha; sCount++; sParticles[sCount] = np;
            }
            if (iRatio > 1.5 && Math.random() < (iRatio - 1.5) * 1.8) {
                const np = createSParticle(); np.originalAlpha = np.alpha; sCount++; sParticles[sCount] = np;
            }
            if (sCount > maxParticles + 200) {
                const excess = Math.min(15, sCount - maxParticles);
                for (let x = 0; x < excess; x++) { sParticles[sCount - x] = null; }
                sCount -= excess;
            }

            scanRafId = requestAnimationFrame(animateScanner);
        }
        animateScanner();

        /* ── resize handler ── */
        function onResize() {
            cW = container!.offsetWidth;
            cH = container!.offsetHeight;
            cardLineWidth = (cardWidth + cardGap) * cardCount;
            camera.left = -cW / 2; camera.right = cW / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(cW, 250);
            sW = cW;
            scannerCanvas!.width = sW;
            scannerCanvas!.height = sH;
        }
        window.addEventListener('resize', onResize);

        /* ── cleanup ── */
        cleanupRef.current = () => {
            cancelAnimationFrame(cardRafId);
            cancelAnimationFrame(threeRafId);
            cancelAnimationFrame(scanRafId);
            clearInterval(asciiTimer);
            window.removeEventListener('resize', onResize);
            cardLine.removeEventListener('mousedown', onMouseDown);
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            cardLine.removeEventListener('touchstart', onTouchStart);
            document.removeEventListener('touchmove', onTouchMove);
            document.removeEventListener('touchend', onTouchEnd);
            cardLine.removeEventListener('wheel', onWheel);
            renderer.dispose();
            scene.remove(points);
            geom.dispose();
            mat.dispose();
        };

        return () => { cleanupRef.current?.(); };
    }, [buildCards]);

    /* ─── JSX ─── */
    return (
        <>
            <div ref={containerRef} className="cs-container">
                {/* Gradient overlay for text readability */}
                <div className="cs-gradient-overlay" />

                {/* Header: Logo + Title */}
                <div className="cs-header">
                    <div className="cs-logo-row">
                        <span className="cs-logo-text">MEDELISE</span>
                        <div className="cs-logo-line" />
                    </div>
                    <div className="cs-title-block">
                        <h2 className="cs-title">Simplify Medical Management</h2>
                        <p className="cs-desc">
                            Streamline patient care, appointments, and medical records
                            in one powerful dashboard. Experience the ease of managing
                            your healthcare services with MedKit
                        </p>
                    </div>
                </div>

                <canvas ref={particleCanvasRef} className="cs-particle-canvas" />
                <canvas ref={scannerCanvasRef} className="cs-scanner-canvas" />
                <div className="cs-card-stream">
                    <div ref={cardLineRef} className="cs-card-line" />
                </div>
            </div>

            <style jsx>{`
        .cs-container {
          position: relative;
          width: 100%;
          height: 100%;
          display: flex;
          align-items: center;
          justify-content: center;
          overflow: hidden;
          background: #000;
          border-radius: inherit;
        }

        .cs-gradient-overlay {
          position: absolute;
          inset: 0;
          background: linear-gradient(
            180deg,
            rgba(0, 0, 0, 0.7) 0%,
            rgba(0, 0, 0, 0.3) 30%,
            rgba(0, 0, 0, 0) 50%
          );
          z-index: 20;
          pointer-events: none;
        }

        .cs-header {
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          z-index: 21;
          display: flex;
          flex-direction: column;
          gap: 24px;
          padding: 64px 32px 0 32px;
        }

        .cs-logo-row {
          display: flex;
          align-items: center;
          gap: 20px;
        }

        .cs-logo-text {
          font-family: var(--font-michroma), Michroma, sans-serif;
          font-size: 24px;
          text-transform: uppercase;
          color: white;
          letter-spacing: 0.05em;
          line-height: 1;
        }

        .cs-logo-line {
          flex: 1;
          height: 1px;
          background: #DFE1E7;
        }

        .cs-title-block {
          max-width: 510px;
          display: flex;
          flex-direction: column;
          gap: 16px;
        }

        .cs-title {
          color: white;
          font-size: 48px;
          font-family: var(--font-dm-sans), 'DM Sans', sans-serif;
          font-weight: 500;
          line-height: 57.6px;
          margin: 0;
        }

        .cs-desc {
          color: white;
          font-size: 16px;
          font-family: var(--font-dm-sans), 'DM Sans', sans-serif;
          font-weight: 500;
          line-height: 25.6px;
          margin: 0;
          opacity: 0.9;
        }

        .cs-card-stream {
          position: absolute;
          width: 100%;
          height: 150px;
          display: flex;
          align-items: center;
          overflow: visible;
        }

        .cs-card-line {
          display: flex;
          align-items: center;
          gap: 60px;
          white-space: nowrap;
          cursor: grab;
          user-select: none;
          will-change: transform;
        }
        .cs-card-line:active { cursor: grabbing; }

        .cs-particle-canvas {
          position: absolute;
          top: 50%;
          left: 0;
          transform: translateY(-50%);
          width: 100%;
          height: 250px;
          z-index: 0;
          pointer-events: none;
        }

        .cs-scanner-canvas {
          position: absolute;
          top: 50%;
          left: -3px;
          transform: translateY(-50%);
          width: 100%;
          height: 300px;
          z-index: 15;
          pointer-events: none;
        }
      `}</style>

            {/* card / ascii styles — global so they apply to dynamically-created DOM */}
            <style jsx global>{`
        .cs-card-wrapper {
          position: relative;
          width: 240px;
          height: 150px;
          flex-shrink: 0;
        }

        .cs-card {
          position: absolute;
          top: 0; left: 0;
          width: 240px;
          height: 150px;
          border-radius: 10px;
          overflow: hidden;
        }

        .cs-card-normal {
          background: transparent;
          box-shadow: 0 15px 40px rgba(0,0,0,0.4);
          z-index: 2;
          clip-path: inset(0 0 0 var(--clip-right, 0%));
        }

        .cs-card-image {
          width: 100%;
          height: 100%;
          object-fit: contain;
          border-radius: 10px;
          background: #0a0a0a;
          filter: brightness(1.1) contrast(1.1);
          transition: filter 0.3s ease;
        }
        .cs-card-image:hover {
          filter: brightness(1.2) contrast(1.2);
        }

        .cs-card-ascii {
          background: transparent;
          z-index: 1;
          clip-path: inset(0 calc(100% - var(--clip-left, 0%)) 0 0);
        }

        .cs-ascii-content {
          position: absolute;
          top: 0; left: 0;
          width: 100%; height: 100%;
          color: rgba(200,180,255,1);
          font-family: 'Courier New', monospace;
          font-size: 11px;
          line-height: 13px;
          overflow: hidden;
          white-space: pre;
          margin: 0; padding: 0;
          animation: cs-glitch 0.1s infinite linear alternate-reverse;
          -webkit-mask-image: radial-gradient(circle at center, rgba(0,0,0,1) 0%, rgba(0,0,0,0.8) 30%, rgba(0,0,0,0.4) 60%, rgba(0,0,0,0) 70%);
          mask-image: radial-gradient(circle at center, rgba(0,0,0,1) 0%, rgba(0,0,0,0.8) 30%, rgba(0,0,0,0.4) 60%, rgba(0,0,0,0) 70%);
        }

        @keyframes cs-glitch {
          0%   { opacity: 1; }
          15%  { opacity: 0.9; }
          16%  { opacity: 1; }
          49%  { opacity: 0.8; }
          50%  { opacity: 1; }
          99%  { opacity: 0.9; }
          100% { opacity: 1; }
        }

        .cs-scan-effect {
          position: absolute;
          top: 0; left: 0;
          width: 100%; height: 100%;
          background: linear-gradient(90deg, transparent, rgba(0,255,255,0.4), transparent);
          animation: cs-scanFx 0.6s ease-out;
          pointer-events: none;
          z-index: 5;
        }

        @keyframes cs-scanFx {
          0%   { transform: translateX(-100%); opacity: 0; }
          50%  { opacity: 1; }
          100% { transform: translateX(100%); opacity: 0; }
        }
      `}</style>
        </>
    );
}
